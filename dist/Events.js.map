{"version":3,"file":"Events.js","sourceRoot":"","sources":["../src/Events.ts"],"names":[],"mappings":";;;AAYA,MAAa,MAAM;IACjB,GAAG,CAAkB;IACrB,QAAQ,CAAmE;IAC3E,YAAY,GAAoB;QAC9B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QAEf,IAAI,CAAC,QAAQ,GAAG;YACd,iBAAiB,EAAE,EAAE;YACrB,gBAAgB,EAAE,EAAE;YACpB,oBAAoB,EAAE,EAAE;YACxB,WAAW,EAAE,EAAE;YACf,UAAU,EAAE,EAAE;YACd,gBAAgB,EAAE,EAAE;YACpB,UAAU,EAAE,EAAE;SACf,CAAA;IACH,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,IAAoB,EAAE,IAAS;QAC3C,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,QAAQ;YAAE,OAAO,IAAI,CAAC;QAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACxC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,QAAQ,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;YACnC,IAAI,QAAQ,KAAK,IAAI;gBAAE,OAAO,KAAK,CAAC;SACrC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAiCD,EAAE,CAAC,SAAyB,EAAE,OAAkD,EAAE,UAA6B,EAAE,IAAI,EAAE,KAAK,EAAE;QAC5H,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC;YAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;QAC5E,IAAI,OAAO,CAAC,IAAI,EAAE;YAChB,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE;gBACf,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;gBACvB,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;YACvB,CAAC,CAAC;YACF,IAAI,CAAC,EAAE,CAAC,SAAgB,EAAE,CAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;YACrD,OAAO,GAAG,EAAE;gBACV,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;YACzB,CAAC,CAAA;SACF;aAAM;YACL,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACvC,OAAO,GAAG,EAAE;gBACV,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;YAC/B,CAAC,CAAA;SACF;IACH,CAAC;IAED,GAAG,CAAC,SAAyB,EAAE,OAAkD;QAC/E,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACjC,IAAI,CAAC,CAAC;YAAE,OAAO,EAAE,CAAC;QAClB,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;IACzC,CAAC;CACF;AAnFD,wBAmFC","sourcesContent":["import { NamespaceEnums, NamespaceData } from \"../generated/namespaceData\";\r\nimport { DBI } from \"./DBI\";\r\nimport { ClientEvents } from \"./types/Event\";\r\nimport { IDBIBaseExecuteCtx, TDBIRateLimitTypes } from \"./types/Interaction\";\r\nimport { DBILocale } from \"./types/other/Locale\";\r\n\r\nexport type TDBIEventNames = \"beforeInteraction\" | \"afterInteraction\" | \"interactionRateLimit\" | \"beforeEvent\" | \"afterEvent\" | \"interactionError\" | \"eventError\";\r\n\r\nexport type TDBIEventHandlerCtx<TNamespace extends NamespaceEnums> = {\r\n  [K in keyof (ClientEvents & NamespaceData[TNamespace][\"customEvents\"])]: { other: Record<string, any>, locale?: { guild: DBILocale<TNamespace> }, eventName: K } & (ClientEvents & NamespaceData[TNamespace][\"customEvents\"])[K]\r\n}[keyof (ClientEvents & NamespaceData[TNamespace][\"customEvents\"])];\r\n\r\nexport class Events<TNamespace extends NamespaceEnums> {\r\n  DBI: DBI<TNamespace>;\r\n  handlers: Record<string, Array<(data: any) => boolean | Promise<boolean>>>;\r\n  constructor(DBI: DBI<TNamespace>) {\r\n    this.DBI = DBI;\r\n\r\n    this.handlers = {\r\n      beforeInteraction: [],\r\n      afterInteraction: [],\r\n      interactionRateLimit: [],\r\n      beforeEvent: [],\r\n      afterEvent: [],\r\n      interactionError: [],\r\n      eventError: []\r\n    }\r\n  }\r\n  \r\n  async trigger(name: TDBIEventNames, data: any): Promise<boolean> {\r\n    let handlers = this.handlers[name];\r\n    if (!handlers) return true;\r\n    for (let i = 0; i < handlers.length; i++) {\r\n      const handler = handlers[i];\r\n      let returned = await handler(data);\r\n      if (returned !== true) return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n\r\n  on(\r\n    eventName: \"beforeInteraction\" | \"afterInteraction\",\r\n    handler: (data: IDBIBaseExecuteCtx<TNamespace>) => Promise<boolean> | boolean,\r\n    options?: { once: boolean }\r\n  ): (() => any);\r\n\r\n  on(\r\n    eventName: \"interactionError\",\r\n    handler: (data: IDBIBaseExecuteCtx<TNamespace> & { error: any }) => Promise<boolean> | boolean,\r\n    options?: { once: boolean }\r\n  ): (() => any);\r\n\r\n  on(\r\n    eventName: \"beforeEvent\" | \"afterEvent\",\r\n    handler: (data: TDBIEventHandlerCtx<TNamespace>) => Promise<boolean> | boolean,\r\n    options?: { once: boolean }\r\n  ): (() => any);\r\n\r\n  on(\r\n    eventName: \"eventError\",\r\n    handler: (data: TDBIEventHandlerCtx<TNamespace> & { error: any }) => Promise<boolean> | boolean,\r\n    options?: { once: boolean }\r\n  ): (() => any);\r\n\r\n  on(\r\n    eventName: \"interactionRateLimit\",\r\n    handler: (data: Omit<IDBIBaseExecuteCtx<TNamespace>, \"other\" | \"setRateLimit\"> & { rateLimit: { type: TDBIRateLimitTypes, duration: number, at: number } }) => Promise<boolean> | boolean,\r\n    options?: { once: boolean }\r\n  ): (() => any);\r\n\r\n  on(eventName: TDBIEventNames, handler: (data: any) => Promise<boolean> | boolean, options: { once: boolean } = { once: false }): (() => any) {\r\n    if (!this.handlers.hasOwnProperty(eventName)) this.handlers[eventName] = [];\r\n    if (options.once) {\r\n      let h = (data) => {\r\n        this.off(eventName, h);\r\n        return handler(data);\r\n      };\r\n      this.on(eventName as any, h as any, { once: false });\r\n      return () => {\r\n        this.off(eventName, h);\r\n      }\r\n    } else {\r\n      this.handlers[eventName].push(handler);\r\n      return () => {\r\n        this.off(eventName, handler);\r\n      }\r\n    }\r\n  }\r\n\r\n  off(eventName: TDBIEventNames, handler: (data: any) => Promise<boolean> | boolean) {\r\n    let l = this.handlers[eventName];\r\n    if (!l) return [];\r\n    return l.splice(l.indexOf(handler), 1);\r\n  }\r\n}"]}